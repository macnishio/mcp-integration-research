/**
 * Universal Provider Template Generator
 * Research implementation for automated provider extension
 * 
 * Based on: "Dynamic Cloud Provider Integration in Multi-Cloud Platform Architectures"
 * Digital Autograph Research Team, 2025
 */

import { createHash } from 'crypto';

export class ProviderTemplate {
  /**
   * Generate complete provider implementation from configuration
   * @param {string} providerName - Name of the provider (e.g., 'Google', 'Salesforce')
   * @param {object} config - Provider configuration object
   * @returns {object} Generated template files
   */
  static generate(providerName, config) {
    return {
      authFile: this.generateAuthTemplate(providerName, config),
      toolsFile: this.generateToolsTemplate(providerName, config),
      testFile: this.generateTestTemplate(providerName, config),
      configFile: this.generateConfigTemplate(providerName, config),
      documentationFile: this.generateDocumentation(providerName, config)
    };
  }

  /**
   * Generate authentication template
   */
  static generateAuthTemplate(providerName, config) {
    const className = `${providerName}Auth`;
    const oauth = config.oauth || {};
    
    return `/**
 * Auto-generated ${providerName} Authentication Module
 * Generated by MCP Integration Research Template System
 * 
 * Provider: ${providerName}
 * OAuth Version: ${oauth.version || '2.1'}
 * PKCE Required: ${oauth.requires_pkce || false}
 */

import { createHash } from 'crypto';
import fetch from 'node-fetch';

export class ${className} {
  constructor(config) {
    this.config = config;
    this.authUrl = '${oauth.auth_url || ''}';
    this.tokenUrl = '${oauth.token_url || ''}';
    this.scopes = ${JSON.stringify(oauth.scopes || [], null, 4)};
    this.requiresPkce = ${oauth.requires_pkce || false};
  }

  /**
   * Research implementation: Universal UUID conversion
   * Converts arbitrary user IDs to UUID format for database compatibility
   */
  validateOrConvertUserId(userId) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    
    if (uuidRegex.test(userId)) {
      return userId;
    }
    
    // MD5-based UUID generation for consistency
    const hash = createHash('md5').update(userId).digest('hex');
    return \`\${hash.slice(0,8)}-\${hash.slice(8,12)}-\${hash.slice(12,16)}-\${hash.slice(16,20)}-\${hash.slice(20,32)}\`;
  }

  /**
   * Generate OAuth authorization URL
   */
  async generateAuthUrl(state, redirectUri) {
    const params = new URLSearchParams({
      response_type: 'code',
      client_id: this.config.clientId,
      redirect_uri: redirectUri,
      scope: this.scopes.join(' '),
      state: JSON.stringify(state),
      access_type: 'offline'
    });

    ${oauth.requires_pkce ? `
    // PKCE implementation
    const codeVerifier = this.generateCodeVerifier();
    const codeChallenge = await this.generateCodeChallenge(codeVerifier);
    params.append('code_challenge', codeChallenge);
    params.append('code_challenge_method', 'S256');
    
    // Store code verifier for token exchange
    this.config.codeVerifier = codeVerifier;
    ` : ''}

    return \`\${this.authUrl}?\${params.toString()}\`;
  }

  /**
   * Exchange authorization code for tokens
   */
  async handleAuthCode(code, state) {
    const params = {
      grant_type: 'authorization_code',
      code: code,
      client_id: this.config.clientId,
      client_secret: this.config.clientSecret,
      redirect_uri: this.config.redirectUri
    };

    ${oauth.requires_pkce ? `
    // Include PKCE verifier
    if (this.config.codeVerifier) {
      params.code_verifier = this.config.codeVerifier;
    }
    ` : ''}

    const response = await fetch(this.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams(params)
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Token exchange failed: \${error}\`);
    }

    const tokens = await response.json();
    return {
      accessToken: tokens.access_token,
      refreshToken: tokens.refresh_token,
      expiresIn: tokens.expires_in,
      tokenType: tokens.token_type
    };
  }

  /**
   * Refresh access token
   */
  async refreshAccessToken(refreshToken) {
    const params = {
      grant_type: 'refresh_token',
      refresh_token: refreshToken,
      client_id: this.config.clientId,
      client_secret: this.config.clientSecret
    };

    const response = await fetch(this.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams(params)
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Token refresh failed: \${error}\`);
    }

    const tokens = await response.json();
    return {
      accessToken: tokens.access_token,
      refreshToken: tokens.refresh_token || refreshToken,
      expiresIn: tokens.expires_in
    };
  }

  ${oauth.requires_pkce ? `
  /**
   * PKCE helper: Generate code verifier
   */
  generateCodeVerifier() {
    const buffer = Buffer.alloc(32);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = Math.floor(Math.random() * 256);
    }
    return buffer.toString('base64url');
  }

  /**
   * PKCE helper: Generate code challenge
   */
  async generateCodeChallenge(verifier) {
    const hash = createHash('sha256').update(verifier).digest();
    return hash.toString('base64url');
  }
  ` : ''}

  /**
   * Make authenticated API call
   */
  async makeApiCall(method, endpoint, data = null, headers = {}) {
    const url = \`\${this.config.baseUrl}\${endpoint}\`;
    
    const requestHeaders = {
      'Authorization': \`Bearer \${this.config.accessToken}\`,
      'Content-Type': 'application/json',
      ...headers
    };

    const options = {
      method,
      headers: requestHeaders
    };

    if (data && method !== 'GET') {
      options.body = JSON.stringify(data);
    }

    const response = await fetch(url, options);
    
    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`API call failed: \${response.status} - \${error}\`);
    }

    return response.json();
  }
}

export default ${className};`;
  }

  /**
   * Generate tools template
   */
  static generateToolsTemplate(providerName, config) {
    const className = `${providerName}Tools`;
    const services = config.services || {};
    
    return `/**
 * Auto-generated ${providerName} Tools Implementation
 * Generated by MCP Integration Research Template System
 */

export class ${className} {
  constructor(auth) {
    this.auth = auth;
    this.provider = '${providerName.toLowerCase()}';
  }

  /**
   * Get all available tools for this provider
   */
  getTools() {
    return [
${Object.entries(services).map(([serviceName, service]) => 
  (service.tools || []).map(tool => `      {
        name: '${providerName.toLowerCase()}_${tool.name}',
        description: '${tool.description || `${tool.name} operation for ${serviceName}`}',
        inputSchema: {
          type: 'object',
          properties: ${JSON.stringify(tool.parameters || {}, null, 10)},
          required: ${JSON.stringify(tool.required || [])}
        }
      }`).join(',\n')
).join(',\n')}
    ];
  }

  /**
   * Execute a tool by name
   */
  async executeTool(toolName, args) {
    const tool = this.getTools().find(t => t.name === toolName);
    if (!tool) {
      throw new Error(\`Tool \${toolName} not found\`);
    }

    // Extract service and operation from tool name
    const parts = toolName.split('_');
    const operation = parts.slice(1).join('_');

    // Find the corresponding service configuration
    ${Object.entries(services).map(([serviceName, service]) => `
    if (toolName.includes('${serviceName}')) {
      return this.execute${serviceName.charAt(0).toUpperCase() + serviceName.slice(1)}Operation(operation, args);
    }`).join('')}

    throw new Error(\`Unable to execute tool \${toolName}\`);
  }

${Object.entries(services).map(([serviceName, service]) => `
  /**
   * Execute ${serviceName} operations
   */
  async execute${serviceName.charAt(0).toUpperCase() + serviceName.slice(1)}Operation(operation, args) {
    const baseUrl = '${service.base_url || ''}';
    
    // Map operation to endpoint
    const tool = ${JSON.stringify(service.tools || [])}.find(t => t.name === operation);
    if (!tool) {
      throw new Error(\`Operation \${operation} not found in ${serviceName}\`);
    }

    // Make API call
    return this.auth.makeApiCall(
      tool.method || 'GET',
      \`\${baseUrl}\${tool.endpoint}\`,
      args
    );
  }`).join('\n')}
}

export default ${className};`;
  }

  /**
   * Generate test template
   */
  static generateTestTemplate(providerName, config) {
    return `/**
 * Auto-generated ${providerName} Test Suite
 * Generated by MCP Integration Research Template System
 */

import { test } from 'node:test';
import assert from 'node:assert';
import { ${providerName}Auth } from '../implementations/${providerName.toLowerCase()}/auth.mjs';
import { ${providerName}Tools } from '../implementations/${providerName.toLowerCase()}/tools.mjs';

test('${providerName} Authentication', async (t) => {
  await t.test('UUID conversion', () => {
    const auth = new ${providerName}Auth({});
    
    // Test non-UUID conversion
    const userId = 'user-test-123';
    const uuid = auth.validateOrConvertUserId(userId);
    assert.match(uuid, /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);
    
    // Test existing UUID preservation
    const existingUuid = '550e8400-e29b-41d4-a716-446655440000';
    const preserved = auth.validateOrConvertUserId(existingUuid);
    assert.strictEqual(preserved, existingUuid);
  });

  await t.test('Auth URL generation', async () => {
    const auth = new ${providerName}Auth({
      clientId: 'test-client-id'
    });
    
    const state = { userId: 'test-user', service: 'test' };
    const redirectUri = 'http://localhost:3000/callback';
    
    const authUrl = await auth.generateAuthUrl(state, redirectUri);
    assert.ok(authUrl.includes('${config.oauth?.auth_url || 'oauth'}'));
    assert.ok(authUrl.includes('client_id=test-client-id'));
  });
});

test('${providerName} Tools', async (t) => {
  await t.test('Tool registration', () => {
    const auth = new ${providerName}Auth({});
    const tools = new ${providerName}Tools(auth);
    
    const toolList = tools.getTools();
    assert.ok(Array.isArray(toolList));
    assert.ok(toolList.length > 0);
    
    // Check tool naming convention
    toolList.forEach(tool => {
      assert.ok(tool.name.startsWith('${providerName.toLowerCase()}_'));
    });
  });
});`;
  }

  /**
   * Generate configuration template
   */
  static generateConfigTemplate(providerName, config) {
    return JSON.stringify({
      provider: {
        name: providerName,
        type: providerName.toLowerCase(),
        version: '1.0.0'
      },
      oauth: config.oauth || {},
      services: config.services || {},
      rate_limits: config.rate_limits || {
        default: 1000,
        burst: 2000
      },
      error_patterns: config.error_patterns || {
        authentication: [
          { pattern: 'invalid_grant', action: 'refresh_token' },
          { pattern: 'unauthorized', action: 'reauthorize' }
        ],
        rate_limit: [
          { pattern: 'rate_limit_exceeded', action: 'exponential_backoff' }
        ]
      }
    }, null, 2);
  }

  /**
   * Generate documentation
   */
  static generateDocumentation(providerName, config) {
    const services = config.services || {};
    const toolCount = Object.values(services).reduce((sum, service) => 
      sum + (service.tools || []).length, 0);

    return `# ${providerName} Provider Integration

Auto-generated documentation for ${providerName} provider integration.

## Overview

- **Provider**: ${providerName}
- **Services**: ${Object.keys(services).join(', ')}
- **Total Tools**: ${toolCount}
- **OAuth Version**: ${config.oauth?.version || '2.1'}
- **PKCE Required**: ${config.oauth?.requires_pkce || false}

## Authentication

### OAuth Configuration

- **Authorization URL**: \`${config.oauth?.auth_url || 'Not configured'}\`
- **Token URL**: \`${config.oauth?.token_url || 'Not configured'}\`
- **Scopes**: ${(config.oauth?.scopes || []).map(s => `\`${s}\``).join(', ')}

## Services

${Object.entries(services).map(([serviceName, service]) => `
### ${serviceName.charAt(0).toUpperCase() + serviceName.slice(1)}

- **Base URL**: \`${service.base_url || 'Not configured'}\`
- **Rate Limit**: ${service.rate_limit || 'Default'} requests/second
- **Tools**: ${(service.tools || []).length}

#### Available Operations

${(service.tools || []).map(tool => `
- **${tool.name}**
  - Endpoint: \`${tool.method || 'GET'} ${tool.endpoint}\`
  - Description: ${tool.description || 'No description'}
  - Parameters: ${Object.keys(tool.parameters || {}).join(', ') || 'None'}
`).join('')}
`).join('')}

## Usage Example

\`\`\`javascript
import { ${providerName}Auth } from './${providerName.toLowerCase()}/auth.mjs';
import { ${providerName}Tools } from './${providerName.toLowerCase()}/tools.mjs';

// Initialize authentication
const auth = new ${providerName}Auth({
  clientId: process.env.${providerName.toUpperCase()}_CLIENT_ID,
  clientSecret: process.env.${providerName.toUpperCase()}_CLIENT_SECRET
});

// Generate auth URL
const authUrl = await auth.generateAuthUrl(state, redirectUri);

// Exchange code for tokens
const tokens = await auth.handleAuthCode(code, state);

// Initialize tools
const tools = new ${providerName}Tools(auth);

// Execute a tool
const result = await tools.executeTool('${providerName.toLowerCase()}_${(services[Object.keys(services)[0]]?.tools?.[0]?.name) || 'example'}', {
  // parameters
});
\`\`\`

## Error Handling

The integration includes standardized error handling for:
- OAuth authentication failures
- Rate limiting
- API errors
- Network issues

## Generated

This documentation was auto-generated by the MCP Integration Research Template System.
Generated on: ${new Date().toISOString()}
`;
  }
}

export default ProviderTemplate;